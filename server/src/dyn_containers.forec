/*
*
* Copyright (C) 2020 University of Bamberg, Software Technologies Research Group
* <https://www.uni-bamberg.de/>, <http://www.swt-bamberg.de/>
* 
* This file is part of the SWTbahn command line interface (swtbahn-cli), which is
* a client-server application to interactively control a BiDiB model railway.
*
* swtbahn-cli is licensed under the GNU GENERAL PUBLIC LICENSE (Version 3), see
* the LICENSE file at the project's top-level directory for details or consult
* <http://www.gnu.org/licenses/>.
*
* swtbahn-cli is free software: you can redistribute it and/or modify it under the
* terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or any later version.
*
* swtbahn-cli is a RESEARCH PROTOTYPE and distributed WITHOUT ANY WARRANTY, without
* even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
* PURPOSE. See the GNU General Public License for more details.
*
* The following people contributed to the conception and realization of the
* present swtbahn-cli (in alphabetic order by surname):
*
* - Eugene Yip <https://github.com/eyip002>
*
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <libgen.h>

#include "dynlib.h"
#include "tick_data.h"
#include "server.h"

#include "dyn_containers_interface.h"

typedef void t_dyn_containers_interface;
#define t_dyn_containers_interface__global_0_0 t_dyn_containers_interface

typedef void t_dyn_shm_config;
#define t_dyn_shm_config__global_0_0 t_dyn_shm_config

#define dyn_containers_mutex__global_0_0 dyn_containers_mutex

typedef void pthread_mutex_t;
#define pthread_mutex_t__global_0_0 pthread_mutex_t

typedef void key_t;
#define key_t__global_0_0 key_t

typedef int bool;
#define bool__global_0_0 bool

shared int LOG_NOTICE = 5;

int LOG_ERR;
#define LOG_ERR__global_0_0 LOG_ERR

int PATH_MAX;
#define PATH_MAX__global_0_0 PATH_MAX

shared int path_max = PATH_MAX;

int NAME_MAX;
#define NAME_MAX__global_0_0 NAME_MAX

shared int name_max = NAME_MAX;

typedef void dynlib_status;
#define dynlib_status__global_0_0 dynlib_status

typedef void dynlib_data;
#define dynlib_data__global_0_0 dynlib_data

int DYNLIB_COMPILE_SUCCESS;
#define DYNLIB_COMPILE_SUCCESS__global_0_0 DYNLIB_COMPILE_SUCCESS

int DYNLIB_LOAD_SUCCESS;
#define DYNLIB_LOAD_SUCCESS__global_0_0 DYNLIB_LOAD_SUCCESS

shared int dynlib_load_success = DYNLIB_LOAD_SUCCESS;

int DYNLIB_COMPILE_SCCHARTS_C_ERR;
#define DYNLIB_COMPILE_SCCHARTS_C_ERR__global_0_0 DYNLIB_COMPILE_SCCHARTS_C_ERR

int DYNLIB_COMPILE_SHARED_BAHNDSL_ERR;
#define DYNLIB_COMPILE_SHARED_BAHNDSL_ERR__global_0_0 DYNLIB_COMPILE_SHARED_BAHNDSL_ERR

int DYNLIB_COMPILE_SHARED_SCCHARTS_ERR;
#define DYNLIB_COMPILE_SHARED_SCCHARTS_ERR__global_0_0 DYNLIB_COMPILE_SHARED_SCCHARTS_ERR

int DYNLIB_LOAD_ERR;
#define DYNLIB_LOAD_ERR__global_0_0 DYNLIB_LOAD_ERR

int DYNLIB_LOAD_RESET_ERR;
#define DYNLIB_LOAD_RESET_ERR__global_0_0 DYNLIB_LOAD_RESET_ERR

int DYNLIB_LOAD_TICK_ERR;
#define DYNLIB_LOAD_TICK_ERR__global_0_0 DYNLIB_LOAD_TICK_ERR

int TRAIN_ENGINE;
#define TRAIN_ENGINE__global_0_0 TRAIN_ENGINE

int INTERLOCKER;
#define INTERLOCKER__global_0_0 INTERLOCKER

int DRIVE_ROUTE;
#define DRIVE_ROUTE__global_0_0 DRIVE_ROUTE

typedef void TickData_train_engine;
#define TickData_train_engine__global_0_0 TickData_train_engine

typedef void TickData_interlocker;
#define TickData_interlocker__global_0_0 TickData_interlocker

typedef void TickData_drive_route;
#define TickData_drive_route__global_0_0 TickData_drive_route


// Data needed by the dynamic libraries
shared static const unsigned int TRAIN_ENGINE_COUNT_MAX = 4;
static const unsigned int INTERLOCKER_COUNT_MAX  = 4;
shared dynlib_data trainEngines[TRAIN_ENGINE_COUNT_MAX];
shared dynlib_data interlockers[INTERLOCKER_COUNT_MAX];

// Train engines that are available at compile time
static const unsigned int TRAIN_ENGINE_DEFINED_COUNT = 2;
const char *trainEngineFilepaths[TRAIN_ENGINE_DEFINED_COUNT] = {
	"../src/engines/libtrain_engine_default (unremovable)",
	"../src/engines/libtrain_engine_linear (unremovable)"
};

// Interlockers that are available at compile time
static const unsigned int INTERLOCKER_DEFINED_COUNT = 2;
const char *interlockerFilepaths[INTERLOCKER_DEFINED_COUNT] = {
	"../src/interlockers/libinterlocker_default (unremovable)",
	"../src/interlockers/libinterlocker_simple_sectional (unremovable)"
};


// Data needed by instances of train engines and interlocking algorithms
static const unsigned int TRAIN_ENGINE_INSTANCE_COUNT_MAX = 5;
static const unsigned int INTERLOCKER_INSTANCE_COUNT_MAX  = 4;
TickData_train_engine trainEngineInstanceDataIntern[TRAIN_ENGINE_INSTANCE_COUNT_MAX];
TickData_interlocker interlockerInstanceDataIntern[INTERLOCKER_INSTANCE_COUNT_MAX];
shared TickData_train_engine *trainEngineInstanceData = trainEngineInstanceDataIntern combine with keepOneCombineEngine;
shared TickData_interlocker *interlockerInstanceData = interlockerInstanceDataIntern combine with keepOneCombineInterlocker;


// Interface with the environment
typedef struct {
	volatile bool terminate;			// Whether to terminate program execution
	int let_period_us;					// Period of the Logical Execution Time (LET) in microseconds
} t_forec_intern_input;
shared t_forec_intern_input forec_intern_input = {.terminate = false, .let_period_us = 0};

// Train engine information
typedef struct {
	volatile bool load;					// Load the train engine specified by file path
	volatile bool unload;				// Unload the train engine
	char filepath[PATH_MAX + NAME_MAX];	// File path of library source code, without the file extension
} t_forec_intern_input_train_engine;
shared t_forec_intern_input_train_engine forec_intern_input_train_engine_0 = {.filepath = ""};
shared t_forec_intern_input_train_engine forec_intern_input_train_engine_1 = {.filepath = ""};
shared t_forec_intern_input_train_engine forec_intern_input_train_engine_2 = {.filepath = ""};
shared t_forec_intern_input_train_engine forec_intern_input_train_engine_3 = {.filepath = ""};

typedef struct {
	volatile bool in_use;				// Whether the container is still in use
	char *name;							// Name of the train engine when loaded
} t_forec_intern_output_train_engine;
shared t_forec_intern_output_train_engine forec_intern_output_train_engine_0 = {.in_use = false, .name = ""};
shared t_forec_intern_output_train_engine forec_intern_output_train_engine_1 = {.in_use = false, .name = ""};
shared t_forec_intern_output_train_engine forec_intern_output_train_engine_2 = {.in_use = false, .name = ""};
shared t_forec_intern_output_train_engine forec_intern_output_train_engine_3 = {.in_use = false, .name = ""};

// Train engine instance information
typedef struct {
	volatile bool grab;					// Desire to use this instance
	volatile bool release;				// Desire to stop using this instance
	int  train_engine_type;				// Desired train engine to use
	int  requested_speed;				// Input defined by the train engine
	char requested_forwards;			// Input defined by the train engine
} t_forec_intern_input_train_engine_instance;
shared t_forec_intern_input_train_engine_instance forec_intern_input_train_engine_instance_0;
shared t_forec_intern_input_train_engine_instance forec_intern_input_train_engine_instance_1;
shared t_forec_intern_input_train_engine_instance forec_intern_input_train_engine_instance_2;
shared t_forec_intern_input_train_engine_instance forec_intern_input_train_engine_instance_3;
shared t_forec_intern_input_train_engine_instance forec_intern_input_train_engine_instance_4;

typedef struct {	
	volatile bool in_use;				// Whether this instance is still in use
	int  train_engine_type;				// Train engine in use
	int  nominal_speed;					// Output defined by the train engine
	char nominal_forwards;				// Output defined by the train engine
} t_forec_intern_output_train_engine_instance;
shared t_forec_intern_output_train_engine_instance forec_intern_output_train_engine_instance_0 = {.in_use = false, .train_engine_type = -1};
shared t_forec_intern_output_train_engine_instance forec_intern_output_train_engine_instance_1 = {.in_use = false, .train_engine_type = -1};
shared t_forec_intern_output_train_engine_instance forec_intern_output_train_engine_instance_2 = {.in_use = false, .train_engine_type = -1};
shared t_forec_intern_output_train_engine_instance forec_intern_output_train_engine_instance_3 = {.in_use = false, .train_engine_type = -1};
shared t_forec_intern_output_train_engine_instance forec_intern_output_train_engine_instance_4 = {.in_use = false, .train_engine_type = -1};


// Interlocker information
typedef struct {
	volatile bool load;                 // Load the interlocker specified by file path
	volatile bool unload;               // Unload the interlocker
	char filepath[PATH_MAX + NAME_MAX]; // File path of library source code, without the file extension
} t_forec_intern_input_interlocker;
shared t_forec_intern_input_interlocker forec_intern_input_interlocker_0 = {.filepath = ""};
shared t_forec_intern_input_interlocker forec_intern_input_interlocker_1 = {.filepath = ""};
shared t_forec_intern_input_interlocker forec_intern_input_interlocker_2 = {.filepath = ""};
shared t_forec_intern_input_interlocker forec_intern_input_interlocker_3 = {.filepath = ""};

typedef struct {
	volatile bool in_use;				// Whether the container is still in use
	char *name;                         // Name of the interlocker
} t_forec_intern_output_interlocker;
shared t_forec_intern_output_interlocker forec_intern_output_interlocker_0 = {.in_use = false, .name = ""};
shared t_forec_intern_output_interlocker forec_intern_output_interlocker_1 = {.in_use = false, .name = ""};
shared t_forec_intern_output_interlocker forec_intern_output_interlocker_2 = {.in_use = false, .name = ""};
shared t_forec_intern_output_interlocker forec_intern_output_interlocker_3 = {.in_use = false, .name = ""};

// Interlocker instance information
typedef struct {
	volatile bool grab;                 // Desire to use this instance
	volatile bool release;              // Desire to stop using this instance
	int interlocker_type;               // Desired interlocker to use
	volatile bool reset;                // Desire to reset the interlocker

	char src_signal_id[NAME_MAX];       // Input defined by interlocker
	char dst_signal_id[NAME_MAX];       // Input defined by interlocker
	char train_id[NAME_MAX];            // Input defined by interlocker
} t_forec_intern_input_interlocker_instance;
shared t_forec_intern_input_interlocker_instance forec_intern_input_interlocker_instance_0;
shared t_forec_intern_input_interlocker_instance forec_intern_input_interlocker_instance_1;
shared t_forec_intern_input_interlocker_instance forec_intern_input_interlocker_instance_2;
shared t_forec_intern_input_interlocker_instance forec_intern_input_interlocker_instance_3;

typedef struct {
	volatile bool in_use;				// Whether this instance is still in use
	volatile bool has_reset;            // Whether this instance has been reset
	int interlocker_type;               // Interlocker type in use

	char *route_id;                     // Output defined by interlocker
	volatile bool terminated;           // Output defined by interlocker
} t_forec_intern_output_interlocker_instance;
shared t_forec_intern_output_interlocker_instance forec_intern_output_interlocker_instance_0 = {.in_use = false, .has_reset = false, .interlocker_type = -1, .route_id = ""};
shared t_forec_intern_output_interlocker_instance forec_intern_output_interlocker_instance_1 = {.in_use = false, .has_reset = false, .interlocker_type = -1, .route_id = ""};
shared t_forec_intern_output_interlocker_instance forec_intern_output_interlocker_instance_2 = {.in_use = false, .has_reset = false, .interlocker_type = -1, .route_id = ""};
shared t_forec_intern_output_interlocker_instance forec_intern_output_interlocker_instance_3 = {.in_use = false, .has_reset = false, .interlocker_type = -1, .route_id = ""};


long long dyn_containers_reaction_counter = 0;


// Create shared memory
shared t_dyn_containers_interface *dyn_containers_interface;

static t_dyn_shm_config shm_config;
static const int shm_permissions = 0666;
static const key_t shm_key = 1234; 

extern pthread_mutex_t dyn_containers_mutex;

// Function prototypes
void copyFilename(char destination[], const char source[], const int name_len, const int path_len);

void copyEngineInputs(t_forec_intern_input_train_engine *internal, struct t_train_engine_io *external);
void copyEngineOutputs(struct t_train_engine_io *external, t_forec_intern_output_train_engine *internal);
void copyEngineInstanceInputs(t_forec_intern_input_train_engine_instance *internal, struct t_train_engine_instance_io *external);
void copyEngineInstanceOutputs(struct t_train_engine_instance_io *external, t_forec_intern_output_train_engine_instance *internal);

void copyInterlockerInputs(t_forec_intern_input_interlocker *internal, struct t_interlocker_io *external);
void copyInterlockerOutputs(struct t_interlocker_io *external, t_forec_intern_output_interlocker *internal);
void copyInterlockerInstanceInputs(t_forec_intern_input_interlocker_instance *internal, struct t_interlocker_instance_io *external);
void copyInterlockerInstanceOutputs(struct t_interlocker_instance_io *external, t_forec_intern_output_interlocker_instance *internal);

void resetInternalInputs(void);
void resetInternalOutputs(void);

void unloadEngines(void);
void unloadInterlockers(void);
void printout(const char *threadName, const dynlib_status status, const dynlib_data *library);

TickData_train_engine *keepOneCombineEngine(TickData_train_engine *left[], TickData_train_engine *right[]);
TickData_interlocker *keepOneCombineInterlocker(TickData_interlocker *left[], TickData_interlocker *right[]);


// Thread prototypes
thread letInterface(void);
thread loadEngines(void);
thread loadInterlockers(void);

thread engineInstance0(void);
thread engineInstance1(void);
thread engineInstance2(void);
thread engineInstance3(void);
thread engineInstance4(void);

thread interlockerInstance0(void);
thread interlockerInstance1(void);
thread interlockerInstance2(void);
thread interlockerInstance3(void);


void main(int argc, char **argv) {
	syslog_server(LOG_NOTICE, "ForeC: Starting dynamic library containers");
	
	dyn_containers_shm_create(&shm_config, shm_permissions, shm_key, 
	                          &dyn_containers_interface);

	resetInternalInputs();
	resetInternalOutputs();

	abort {
		par(letInterface, loadEngines, loadInterlockers, 
		    engineInstance0, engineInstance1, engineInstance2, engineInstance3, engineInstance4,
		    interlockerInstance0, interlockerInstance1, interlockerInstance2, interlockerInstance3);
	} when (forec_intern_input.terminate);
	
	unloadEngines();
	syslog_server(LOG_NOTICE, "ForeC: Unloaded train engines and instances");
	
	unloadInterlockers();
	syslog_server(LOG_NOTICE, "ForeC: Unloaded interlockers and instances");
	
	dyn_containers_shm_detach(&dyn_containers_interface);
	syslog_server(LOG_NOTICE, "ForeC: Detached shared memory");
}

// Thread to manage the LET interface: Timing, inputs, and outputs
thread letInterface(void) {
	char *threadName;
	threadName = "letInterface";
	syslog_server(LOG_NOTICE, "%s: Started", threadName);
	
	pthread_mutex_lock(&dyn_containers_mutex);
	forec_intern_input.let_period_us = dyn_containers_interface->let_period_us;
	pthread_mutex_unlock(&dyn_containers_mutex);
	
	bool initialised = false;
	
	while (true) {
		//----- Start of tick
		
		// Read inputs into ForeC shared variables
		pthread_mutex_lock(&dyn_containers_mutex);
		forec_intern_input.terminate = dyn_containers_interface->terminate;
		
		copyEngineInputs(&forec_intern_input_train_engine_0, &dyn_containers_interface->train_engines_io[0]);
		copyEngineInputs(&forec_intern_input_train_engine_1, &dyn_containers_interface->train_engines_io[1]);
		copyEngineInputs(&forec_intern_input_train_engine_2, &dyn_containers_interface->train_engines_io[2]);
		copyEngineInputs(&forec_intern_input_train_engine_3, &dyn_containers_interface->train_engines_io[3]);
		
		copyEngineInstanceInputs(&forec_intern_input_train_engine_instance_0, &dyn_containers_interface->train_engine_instances_io[0]);
		copyEngineInstanceInputs(&forec_intern_input_train_engine_instance_1, &dyn_containers_interface->train_engine_instances_io[1]);
		copyEngineInstanceInputs(&forec_intern_input_train_engine_instance_2, &dyn_containers_interface->train_engine_instances_io[2]);
		copyEngineInstanceInputs(&forec_intern_input_train_engine_instance_3, &dyn_containers_interface->train_engine_instances_io[3]);
		copyEngineInstanceInputs(&forec_intern_input_train_engine_instance_4, &dyn_containers_interface->train_engine_instances_io[4]);
	
		copyInterlockerInputs(&forec_intern_input_interlocker_0, &dyn_containers_interface->interlockers_io[0]);
		copyInterlockerInputs(&forec_intern_input_interlocker_1, &dyn_containers_interface->interlockers_io[1]);
		copyInterlockerInputs(&forec_intern_input_interlocker_2, &dyn_containers_interface->interlockers_io[2]);
		copyInterlockerInputs(&forec_intern_input_interlocker_3, &dyn_containers_interface->interlockers_io[3]);
		
		copyInterlockerInstanceInputs(&forec_intern_input_interlocker_instance_0, &dyn_containers_interface->interlocker_instances_io[0]);
		copyInterlockerInstanceInputs(&forec_intern_input_interlocker_instance_1, &dyn_containers_interface->interlocker_instances_io[1]);
		copyInterlockerInstanceInputs(&forec_intern_input_interlocker_instance_2, &dyn_containers_interface->interlocker_instances_io[2]);
		copyInterlockerInstanceInputs(&forec_intern_input_interlocker_instance_3, &dyn_containers_interface->interlocker_instances_io[3]);

		pthread_mutex_unlock(&dyn_containers_mutex);

		
		// Wait to the end of the LET period
		usleep(forec_intern_input.let_period_us);

		
		//----- End of tick
		// Write ForeC shared variables to outputs
		pthread_mutex_lock(&dyn_containers_mutex);

		copyEngineOutputs(&dyn_containers_interface->train_engines_io[0], &forec_intern_output_train_engine_0);
		copyEngineOutputs(&dyn_containers_interface->train_engines_io[1], &forec_intern_output_train_engine_1);
		copyEngineOutputs(&dyn_containers_interface->train_engines_io[2], &forec_intern_output_train_engine_2);
		copyEngineOutputs(&dyn_containers_interface->train_engines_io[3], &forec_intern_output_train_engine_3);

		copyEngineInstanceOutputs(&dyn_containers_interface->train_engine_instances_io[0], &forec_intern_output_train_engine_instance_0);
		copyEngineInstanceOutputs(&dyn_containers_interface->train_engine_instances_io[1], &forec_intern_output_train_engine_instance_1);
		copyEngineInstanceOutputs(&dyn_containers_interface->train_engine_instances_io[2], &forec_intern_output_train_engine_instance_2);
		copyEngineInstanceOutputs(&dyn_containers_interface->train_engine_instances_io[3], &forec_intern_output_train_engine_instance_3);
		copyEngineInstanceOutputs(&dyn_containers_interface->train_engine_instances_io[4], &forec_intern_output_train_engine_instance_4);

		copyInterlockerOutputs(&dyn_containers_interface->interlockers_io[0], &forec_intern_output_interlocker_0);
		copyInterlockerOutputs(&dyn_containers_interface->interlockers_io[1], &forec_intern_output_interlocker_1);
		copyInterlockerOutputs(&dyn_containers_interface->interlockers_io[2], &forec_intern_output_interlocker_2);
		copyInterlockerOutputs(&dyn_containers_interface->interlockers_io[3], &forec_intern_output_interlocker_3);

		copyInterlockerInstanceOutputs(&dyn_containers_interface->interlocker_instances_io[0], &forec_intern_output_interlocker_instance_0);
		copyInterlockerInstanceOutputs(&dyn_containers_interface->interlocker_instances_io[1], &forec_intern_output_interlocker_instance_1);
		copyInterlockerInstanceOutputs(&dyn_containers_interface->interlocker_instances_io[2], &forec_intern_output_interlocker_instance_2);
		copyInterlockerInstanceOutputs(&dyn_containers_interface->interlocker_instances_io[3], &forec_intern_output_interlocker_instance_3);

		pthread_mutex_unlock(&dyn_containers_mutex);

		dyn_containers_reaction_counter++;
		pause;
		
		if (initialised) {
			dyn_containers_interface->running = true;
		}
		initialised = true;
	}
}

thread loadEngines(void) {
	const char *threadName;
	threadName = "loadEngines";
	syslog_server(LOG_NOTICE, "%s: Started", threadName);

	// Load train engines that are already available
	dynlib_status load_status;

	load_status = dynlib_load(&trainEngines[0], trainEngineFilepaths[0], TRAIN_ENGINE);
	printout(threadName, load_status, &trainEngines[0]);
	if (load_status == dynlib_load_success) {
		forec_intern_output_train_engine_0.in_use = true;
		copyFilename(trainEngines[0].name, trainEngineFilepaths[0], name_max, path_max + name_max);
		forec_intern_output_train_engine_0.name = trainEngines[0].name;
	}

	load_status = dynlib_load(&trainEngines[1], trainEngineFilepaths[1], TRAIN_ENGINE);
	printout(threadName, load_status, &trainEngines[1]);
	if (load_status == dynlib_load_success) {
		forec_intern_output_train_engine_1.in_use = true;
		copyFilename(trainEngines[1].name, trainEngineFilepaths[1], name_max, path_max + name_max);
		forec_intern_output_train_engine_1.name = trainEngines[1].name;
	}
	
	while (true) {
		// Container 0
		unsigned int container = 0;
		if (forec_intern_input_train_engine_0.load && !forec_intern_output_train_engine_0.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&trainEngines[container], forec_intern_input_train_engine_0.filepath, TRAIN_ENGINE);
			printout(threadName, load_status, &trainEngines[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_train_engine_0.in_use = true;
				copyFilename(trainEngines[container].name, forec_intern_input_train_engine_0.filepath, name_max, path_max + name_max);
				forec_intern_output_train_engine_0.name = trainEngines[container].name;
			}
		} else if (forec_intern_input_train_engine_0.unload) {
			// Close the previous dynamic library
			dynlib_close(&trainEngines[container]);
			forec_intern_output_train_engine_0.in_use = false;
			forec_intern_output_train_engine_0.name = "";
		}
		
		container = 1;
		if (forec_intern_input_train_engine_1.load && !forec_intern_output_train_engine_1.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&trainEngines[container], forec_intern_input_train_engine_1.filepath, TRAIN_ENGINE);
			printout(threadName, load_status, &trainEngines[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_train_engine_1.in_use = true;
				copyFilename(trainEngines[container].name, forec_intern_input_train_engine_1.filepath, name_max, path_max + name_max);
				forec_intern_output_train_engine_1.name = trainEngines[container].name;
			}
		} else if (forec_intern_input_train_engine_1.unload) {
			// Close the previous dynamic library
			dynlib_close(&trainEngines[container]);
			forec_intern_output_train_engine_1.in_use = false;
			forec_intern_output_train_engine_1.name = "";
		}
		
		container = 2;
		if (forec_intern_input_train_engine_2.load && !forec_intern_output_train_engine_2.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&trainEngines[container], forec_intern_input_train_engine_2.filepath, TRAIN_ENGINE);
			printout(threadName, load_status, &trainEngines[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_train_engine_2.in_use = true;
				copyFilename(trainEngines[container].name, forec_intern_input_train_engine_2.filepath, name_max, path_max + name_max);
				forec_intern_output_train_engine_2.name = trainEngines[container].name;
			}
		} else if (forec_intern_input_train_engine_2.unload) {
			// Close the previous dynamic library
			dynlib_close(&trainEngines[container]);
			forec_intern_output_train_engine_2.in_use = false;
			forec_intern_output_train_engine_2.name = "";
		}
		
		container = 3;
		if (forec_intern_input_train_engine_3.load && !forec_intern_output_train_engine_3.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&trainEngines[container], forec_intern_input_train_engine_3.filepath, TRAIN_ENGINE);
			printout(threadName, load_status, &trainEngines[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_train_engine_3.in_use = true;
				copyFilename(trainEngines[container].name, forec_intern_input_train_engine_3.filepath, name_max, path_max + name_max);
				forec_intern_output_train_engine_3.name = trainEngines[container].name;
			}
		} else if (forec_intern_input_train_engine_3.unload) {
			// Close the previous dynamic library
			dynlib_close(&trainEngines[container]);
			forec_intern_output_train_engine_3.in_use = false;
			forec_intern_output_train_engine_3.name = "";
		}
		
		pause;
	}
}

thread loadInterlockers(void) {
	const char *threadName;
	threadName = "loadInterlockers";
	syslog_server(LOG_NOTICE, "%s: Started", threadName);

	// Load interlockers that are already available
	dynlib_status load_status;

	load_status = dynlib_load(&interlockers[0], interlockerFilepaths[0], INTERLOCKER);
	printout(threadName, load_status, &interlockers[0]);
	if (load_status == dynlib_load_success) {
		forec_intern_output_interlocker_0.in_use = true;
		copyFilename(interlockers[0].name, interlockerFilepaths[0], name_max, path_max + name_max);
		forec_intern_output_interlocker_0.name = interlockers[0].name;
	}
	
	load_status = dynlib_load(&interlockers[1], interlockerFilepaths[1], INTERLOCKER);
	printout(threadName, load_status, &interlockers[1]);
	if (load_status == dynlib_load_success) {
		forec_intern_output_interlocker_1.in_use = true;
		copyFilename(interlockers[1].name, interlockerFilepaths[1], name_max, path_max + name_max);
		forec_intern_output_interlocker_1.name = interlockers[1].name;
	}
	
	while (true) {
		// Container 0
		unsigned int container = 0;
		if (forec_intern_input_interlocker_0.load && !forec_intern_output_interlocker_0.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&interlockers[container], forec_intern_input_interlocker_0.filepath, INTERLOCKER);
			printout(threadName, load_status, &interlockers[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_interlocker_0.in_use = true;
				copyFilename(interlockers[container].name, forec_intern_input_interlocker_0.filepath, name_max, path_max + name_max);
				forec_intern_output_interlocker_0.name = interlockers[container].name;
			}
		} else if (forec_intern_input_interlocker_0.unload) {
			// Close the previous dynamic library
			dynlib_close(&interlockers[container]);
			forec_intern_output_interlocker_0.in_use = false;
			forec_intern_output_interlocker_0.name = "";
		}
		
		container = 1;
		if (forec_intern_input_interlocker_1.load && !forec_intern_output_interlocker_1.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&interlockers[container], forec_intern_input_interlocker_1.filepath, INTERLOCKER);
			printout(threadName, load_status, &interlockers[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_interlocker_1.in_use = true;
				copyFilename(interlockers[container].name, forec_intern_input_interlocker_1.filepath, name_max, path_max + name_max);
				forec_intern_output_interlocker_1.name = interlockers[container].name;
			}
		} else if (forec_intern_input_interlocker_1.unload) {
			// Close the previous dynamic library
			dynlib_close(&interlockers[container]);
			forec_intern_output_interlocker_1.in_use = false;
			forec_intern_output_interlocker_1.name = "";
		}
		
		container = 2;
		if (forec_intern_input_interlocker_2.load && !forec_intern_output_interlocker_2.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&interlockers[container], forec_intern_input_interlocker_2.filepath, INTERLOCKER);
			printout(threadName, load_status, &interlockers[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_interlocker_2.in_use = true;
				copyFilename(interlockers[container].name, forec_intern_input_interlocker_2.filepath, name_max, path_max + name_max);
				forec_intern_output_interlocker_2.name = interlockers[container].name;
			}
		} else if (forec_intern_input_interlocker_2.unload) {
			// Close the previous dynamic library
			dynlib_close(&interlockers[container]);
			forec_intern_output_interlocker_2.in_use = false;
			forec_intern_output_interlocker_2.name = "";
		}
		
		container = 3;
		if (forec_intern_input_interlocker_3.load && !forec_intern_output_interlocker_3.in_use) {
			// Load the new dynamic library
			dynlib_status load_status = dynlib_load(&interlockers[container], forec_intern_input_interlocker_3.filepath, INTERLOCKER);
			printout(threadName, load_status, &interlockers[container]);
			if (load_status == dynlib_load_success) {
				forec_intern_output_interlocker_3.in_use = true;
				copyFilename(interlockers[container].name, forec_intern_input_interlocker_3.filepath, name_max, path_max + name_max);
				forec_intern_output_interlocker_3.name = interlockers[container].name;
			}
		} else if (forec_intern_input_interlocker_3.unload) {
			// Close the previous dynamic library
			dynlib_close(&interlockers[container]);
			forec_intern_output_interlocker_3.in_use = false;
			forec_intern_output_interlocker_3.name = "";
		}
		
		pause;
	}
}


thread engineInstance0(void) {
	unsigned int instance = 0;
	
	const char *threadName;
	threadName = "engineInstance0";
		
	while (true) {
		// Wait for a user to grab a train
		while (!forec_intern_input_train_engine_instance_0.grab) {
			pause;
		}
		
		forec_intern_output_train_engine_instance_0.train_engine_type = forec_intern_input_train_engine_instance_0.train_engine_type;
		forec_intern_output_train_engine_instance_0.in_use = true;
		
		// Reset the data of the train engine instance
		dynlib_train_engine_reset(&trainEngines[forec_intern_output_train_engine_instance_0.train_engine_type], &trainEngineInstanceData[instance]);
		dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_0.train_engine_type], &trainEngineInstanceData[instance]);
		syslog_server(LOG_NOTICE, "%s: Reset container  %d %d -> %d %d", threadName,
		        trainEngineInstanceData[instance].requested_speed,
		        trainEngineInstanceData[instance].requested_forwards,
		        trainEngineInstanceData[instance].nominal_speed,
		        trainEngineInstanceData[instance].nominal_forwards);

		// Execute the chosen train engine
		while (!forec_intern_input_train_engine_instance_0.release) {
			// Copy inputs
			trainEngineInstanceData[instance].requested_speed = forec_intern_input_train_engine_instance_0.requested_speed;
			trainEngineInstanceData[instance].requested_forwards = forec_intern_input_train_engine_instance_0.requested_forwards;
			
			// Execute one tick
			dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_0.train_engine_type], &trainEngineInstanceData[instance]);
			if (trainEngineInstanceData[instance].nominal_speed != forec_intern_output_train_engine_instance_0.nominal_speed
			        || trainEngineInstanceData[instance].nominal_forwards != forec_intern_output_train_engine_instance_0.nominal_forwards) {
				syslog_server(LOG_NOTICE, "%s: %s.tick()  %d %d -> %d %d", threadName, 
						trainEngines[forec_intern_output_train_engine_instance_0.train_engine_type].name,
						trainEngineInstanceData[instance].requested_speed,
						trainEngineInstanceData[instance].requested_forwards,
						trainEngineInstanceData[instance].nominal_speed,
						trainEngineInstanceData[instance].nominal_forwards);
				
				// Update outputs
				forec_intern_output_train_engine_instance_0.nominal_speed = trainEngineInstanceData[instance].nominal_speed;
				forec_intern_output_train_engine_instance_0.nominal_forwards = trainEngineInstanceData[instance].nominal_forwards;
			}
			
			pause;
		}

		forec_intern_output_train_engine_instance_0.train_engine_type = -1;
		forec_intern_output_train_engine_instance_0.in_use = false;
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}

thread engineInstance1(void) {
	unsigned int instance = 1;
	
	const char *threadName;
	threadName = "engineInstance1";
		
	while (true) {
		// Wait for a user to grab a train
		while (!forec_intern_input_train_engine_instance_1.grab) {
			pause;
		}
		
		forec_intern_output_train_engine_instance_1.train_engine_type = forec_intern_input_train_engine_instance_1.train_engine_type;
		forec_intern_output_train_engine_instance_1.in_use = true;
		
		// Reset the data of the train engine instance
		dynlib_train_engine_reset(&trainEngines[forec_intern_output_train_engine_instance_1.train_engine_type], &trainEngineInstanceData[instance]);
		dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_1.train_engine_type], &trainEngineInstanceData[instance]);
		syslog_server(LOG_NOTICE, "%s: Reset container  %d %d -> %d %d", threadName,
		        trainEngineInstanceData[instance].requested_speed,
		        trainEngineInstanceData[instance].requested_forwards,
		        trainEngineInstanceData[instance].nominal_speed,
		        trainEngineInstanceData[instance].nominal_forwards);

		// Execute the chosen train engine
		while (!forec_intern_input_train_engine_instance_1.release) {
			// Copy inputs
			trainEngineInstanceData[instance].requested_speed = forec_intern_input_train_engine_instance_1.requested_speed;
			trainEngineInstanceData[instance].requested_forwards = forec_intern_input_train_engine_instance_1.requested_forwards;
			
			// Execute one tick
			dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_1.train_engine_type], &trainEngineInstanceData[instance]);
			if (trainEngineInstanceData[instance].nominal_speed != forec_intern_output_train_engine_instance_1.nominal_speed
			        || trainEngineInstanceData[instance].nominal_forwards != forec_intern_output_train_engine_instance_1.nominal_forwards) {
				syslog_server(LOG_NOTICE, "%s: %s.tick()  %d %d -> %d %d", threadName, 
						trainEngines[forec_intern_output_train_engine_instance_1.train_engine_type].name,
						trainEngineInstanceData[instance].requested_speed,
						trainEngineInstanceData[instance].requested_forwards,
						trainEngineInstanceData[instance].nominal_speed,
						trainEngineInstanceData[instance].nominal_forwards);
				
				// Update outputs
				forec_intern_output_train_engine_instance_1.nominal_speed = trainEngineInstanceData[instance].nominal_speed;
				forec_intern_output_train_engine_instance_1.nominal_forwards = trainEngineInstanceData[instance].nominal_forwards;
			}
			
			pause;
		}

		forec_intern_output_train_engine_instance_1.train_engine_type = -1;
		forec_intern_output_train_engine_instance_1.in_use = false;
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}

thread engineInstance2(void) {
	unsigned int instance = 2;
	
	const char *threadName;
	threadName = "engineInstance2";
		
	while (true) {
		// Wait for a user to grab a train
		while (!forec_intern_input_train_engine_instance_2.grab) {
			pause;
		}
		
		forec_intern_output_train_engine_instance_2.train_engine_type = forec_intern_input_train_engine_instance_2.train_engine_type;
		forec_intern_output_train_engine_instance_2.in_use = true;
		
		// Reset the data of the train engine instance
		dynlib_train_engine_reset(&trainEngines[forec_intern_output_train_engine_instance_2.train_engine_type], &trainEngineInstanceData[instance]);
		dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_2.train_engine_type], &trainEngineInstanceData[instance]);
		syslog_server(LOG_NOTICE, "%s: Reset container  %d %d -> %d %d", threadName,
		        trainEngineInstanceData[instance].requested_speed,
		        trainEngineInstanceData[instance].requested_forwards,
		        trainEngineInstanceData[instance].nominal_speed,
		        trainEngineInstanceData[instance].nominal_forwards);

		// Execute the chosen train engine
		while (!forec_intern_input_train_engine_instance_2.release) {
			// Copy inputs
			trainEngineInstanceData[instance].requested_speed = forec_intern_input_train_engine_instance_2.requested_speed;
			trainEngineInstanceData[instance].requested_forwards = forec_intern_input_train_engine_instance_2.requested_forwards;
			
			// Execute one tick
			dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_2.train_engine_type], &trainEngineInstanceData[instance]);
			if (trainEngineInstanceData[instance].nominal_speed != forec_intern_output_train_engine_instance_2.nominal_speed
			        || trainEngineInstanceData[instance].nominal_forwards != forec_intern_output_train_engine_instance_2.nominal_forwards) {
				syslog_server(LOG_NOTICE, "%s: %s.tick()  %d %d -> %d %d", threadName, 
						trainEngines[forec_intern_output_train_engine_instance_2.train_engine_type].name,
						trainEngineInstanceData[instance].requested_speed,
						trainEngineInstanceData[instance].requested_forwards,
						trainEngineInstanceData[instance].nominal_speed,
						trainEngineInstanceData[instance].nominal_forwards);
				
				// Update outputs
				forec_intern_output_train_engine_instance_2.nominal_speed = trainEngineInstanceData[instance].nominal_speed;
				forec_intern_output_train_engine_instance_2.nominal_forwards = trainEngineInstanceData[instance].nominal_forwards;
			}
			
			pause;
		}

		forec_intern_output_train_engine_instance_2.train_engine_type = -1;
		forec_intern_output_train_engine_instance_2.in_use = false;
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}

thread engineInstance3(void) {
	unsigned int instance = 3;
	
	const char *threadName;
	threadName = "engineInstance3";
		
	while (true) {
		// Wait for a user to grab a train
		while (!forec_intern_input_train_engine_instance_3.grab) {
			pause;
		}
		
		forec_intern_output_train_engine_instance_3.train_engine_type = forec_intern_input_train_engine_instance_3.train_engine_type;
		forec_intern_output_train_engine_instance_3.in_use = true;
		
		// Reset the data of the train engine instance
		dynlib_train_engine_reset(&trainEngines[forec_intern_output_train_engine_instance_3.train_engine_type], &trainEngineInstanceData[instance]);
		dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_3.train_engine_type], &trainEngineInstanceData[instance]);
		syslog_server(LOG_NOTICE, "%s: Reset container  %d %d -> %d %d", threadName,
		        trainEngineInstanceData[instance].requested_speed,
		        trainEngineInstanceData[instance].requested_forwards,
		        trainEngineInstanceData[instance].nominal_speed,
		        trainEngineInstanceData[instance].nominal_forwards);

		// Execute the chosen train engine
		while (!forec_intern_input_train_engine_instance_3.release) {
			// Copy inputs
			trainEngineInstanceData[instance].requested_speed = forec_intern_input_train_engine_instance_3.requested_speed;
			trainEngineInstanceData[instance].requested_forwards = forec_intern_input_train_engine_instance_3.requested_forwards;
			
			// Execute one tick
			dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_3.train_engine_type], &trainEngineInstanceData[instance]);
			if (trainEngineInstanceData[instance].nominal_speed != forec_intern_output_train_engine_instance_3.nominal_speed
			        || trainEngineInstanceData[instance].nominal_forwards != forec_intern_output_train_engine_instance_3.nominal_forwards) {
				syslog_server(LOG_NOTICE, "%s: %s.tick()  %d %d -> %d %d", threadName, 
						trainEngines[forec_intern_output_train_engine_instance_3.train_engine_type].name,
						trainEngineInstanceData[instance].requested_speed,
						trainEngineInstanceData[instance].requested_forwards,
						trainEngineInstanceData[instance].nominal_speed,
						trainEngineInstanceData[instance].nominal_forwards);
				
				// Update outputs
				forec_intern_output_train_engine_instance_3.nominal_speed = trainEngineInstanceData[instance].nominal_speed;
				forec_intern_output_train_engine_instance_3.nominal_forwards = trainEngineInstanceData[instance].nominal_forwards;
			}
			
			pause;
		}

		forec_intern_output_train_engine_instance_3.train_engine_type = -1;
		forec_intern_output_train_engine_instance_3.in_use = false;
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}

thread engineInstance4(void) {
	unsigned int instance = 4;
	
	const char *threadName;
	threadName = "engineInstance4";
		
	while (true) {
		// Wait for a user to grab a train
		while (!forec_intern_input_train_engine_instance_4.grab) {
			pause;
		}
		
		forec_intern_output_train_engine_instance_4.train_engine_type = forec_intern_input_train_engine_instance_4.train_engine_type;
		forec_intern_output_train_engine_instance_4.in_use = true;
		
		// Reset the data of the train engine instance
		dynlib_train_engine_reset(&trainEngines[forec_intern_output_train_engine_instance_4.train_engine_type], &trainEngineInstanceData[instance]);
		dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_4.train_engine_type], &trainEngineInstanceData[instance]);
		syslog_server(LOG_NOTICE, "%s: Reset container  %d %d -> %d %d", threadName,
		        trainEngineInstanceData[instance].requested_speed,
		        trainEngineInstanceData[instance].requested_forwards,
		        trainEngineInstanceData[instance].nominal_speed,
		        trainEngineInstanceData[instance].nominal_forwards);

		// Execute the chosen train engine
		while (!forec_intern_input_train_engine_instance_4.release) {
			// Copy inputs
			trainEngineInstanceData[instance].requested_speed = forec_intern_input_train_engine_instance_4.requested_speed;
			trainEngineInstanceData[instance].requested_forwards = forec_intern_input_train_engine_instance_4.requested_forwards;
			
			// Execute one tick
			dynlib_train_engine_tick(&trainEngines[forec_intern_output_train_engine_instance_4.train_engine_type], &trainEngineInstanceData[instance]);
			if (trainEngineInstanceData[instance].nominal_speed != forec_intern_output_train_engine_instance_4.nominal_speed
			        || trainEngineInstanceData[instance].nominal_forwards != forec_intern_output_train_engine_instance_4.nominal_forwards) {
				syslog_server(LOG_NOTICE, "%s: %s.tick()  %d %d -> %d %d", threadName, 
						trainEngines[forec_intern_output_train_engine_instance_4.train_engine_type].name,
						trainEngineInstanceData[instance].requested_speed,
						trainEngineInstanceData[instance].requested_forwards,
						trainEngineInstanceData[instance].nominal_speed,
						trainEngineInstanceData[instance].nominal_forwards);
				
				// Update outputs
				forec_intern_output_train_engine_instance_4.nominal_speed = trainEngineInstanceData[instance].nominal_speed;
				forec_intern_output_train_engine_instance_4.nominal_forwards = trainEngineInstanceData[instance].nominal_forwards;
			}
			
			pause;
		}

		forec_intern_output_train_engine_instance_4.train_engine_type = -1;
		forec_intern_output_train_engine_instance_4.in_use = false;
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}


thread interlockerInstance0(void) {
	int NULL; (void)NULL;
	#define NULL__interlockerInstance0_0_0 NULL

	unsigned int instance = 0;
	
	const char *threadName;
	threadName = "interlockerInstance0";
			
	while (true) {
		// Wait for a user to set an interlocker
		while (!forec_intern_input_interlocker_instance_0.grab) {
			pause;
		}
		
		forec_intern_output_interlocker_instance_0.interlocker_type = forec_intern_input_interlocker_instance_0.interlocker_type;
		forec_intern_output_interlocker_instance_0.in_use = true;
		interlockerInstanceData[instance].terminated = true;

		// Execute the chosen interlocker
		while (!forec_intern_input_interlocker_instance_0.release) {
			// Reset the interlocker
			if (forec_intern_input_interlocker_instance_0.reset) {
				// Copy inputs
				interlockerInstanceData[instance].src_signal_id = forec_intern_input_interlocker_instance_0.src_signal_id;
				interlockerInstanceData[instance].dst_signal_id = forec_intern_input_interlocker_instance_0.dst_signal_id;
				interlockerInstanceData[instance].train_id = forec_intern_input_interlocker_instance_0.train_id;

				// Reset the interlocker so that it can execute its algorithm from the start
				dynlib_interlocker_reset(&interlockers[forec_intern_output_interlocker_instance_0.interlocker_type], &interlockerInstanceData[instance]);
				forec_intern_output_interlocker_instance_0.has_reset = true;
		
				if (interlockerInstanceData[instance].route_id == NULL) {
					interlockerInstanceData[instance].route_id = "";
				}
		
				syslog_server(LOG_NOTICE, "%s: %s.reset() %s %s %s -> \"%s\" %d", threadName, 
						      interlockers[forec_intern_output_interlocker_instance_0.interlocker_type].name,
						      interlockerInstanceData[instance].src_signal_id,
						      interlockerInstanceData[instance].dst_signal_id,
						      interlockerInstanceData[instance].train_id,
						      interlockerInstanceData[instance].route_id,
						      interlockerInstanceData[instance].terminated);
				
				// Update outputs
				forec_intern_output_interlocker_instance_0.route_id = interlockerInstanceData[instance].route_id;
				forec_intern_output_interlocker_instance_0.terminated = interlockerInstanceData[instance].terminated;
				
				// Wait for the reset to be false
				while (forec_intern_input_interlocker_instance_0.reset) {
					pause;
				}
			}
			
			forec_intern_output_interlocker_instance_0.has_reset = false;

			// Execute interlocker until it terminates
			if (!interlockerInstanceData[instance].terminated) {

				while (!interlockerInstanceData[instance].terminated) {
					dynlib_interlocker_tick(&interlockers[forec_intern_output_interlocker_instance_0.interlocker_type], &interlockerInstanceData[instance]);

					if (interlockerInstanceData[instance].route_id == NULL) {
						interlockerInstanceData[instance].route_id = "";
					}

					syslog_server(LOG_NOTICE, "%s: %s.tick() %s %s %s -> \"%s\" %d", threadName, 
								  interlockers[forec_intern_output_interlocker_instance_0.interlocker_type].name,
								  interlockerInstanceData[instance].src_signal_id,
								  interlockerInstanceData[instance].dst_signal_id,
								  interlockerInstanceData[instance].train_id,
								  interlockerInstanceData[instance].route_id,
								  interlockerInstanceData[instance].terminated);
					
					// Update outputs
					forec_intern_output_interlocker_instance_0.route_id = interlockerInstanceData[instance].route_id;
					forec_intern_output_interlocker_instance_0.terminated = interlockerInstanceData[instance].terminated;
					
					pause;
				}
			}
			
			pause;
		}

		forec_intern_output_interlocker_instance_0.interlocker_type = -1;
		forec_intern_output_interlocker_instance_0.in_use = false;
		forec_intern_output_interlocker_instance_0.route_id = "";
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}

thread interlockerInstance1(void) {
	int NULL; (void)NULL;
	#define NULL__interlockerInstance1_0_0 NULL
	
	unsigned int instance = 1;
	
	const char *threadName;
	threadName = "interlockerInstance1";
			
	while (true) {
		// Wait for a user to set an interlocker
		while (!forec_intern_input_interlocker_instance_1.grab) {
			pause;
		}
		
		forec_intern_output_interlocker_instance_1.interlocker_type = forec_intern_input_interlocker_instance_1.interlocker_type;
		forec_intern_output_interlocker_instance_1.in_use = true;
		interlockerInstanceData[instance].terminated = true;

		// Execute the chosen interlocker
		while (!forec_intern_input_interlocker_instance_1.release) {
			// Reset the interlocker
			if (forec_intern_input_interlocker_instance_1.reset) {
				// Copy inputs
				interlockerInstanceData[instance].src_signal_id = forec_intern_input_interlocker_instance_1.src_signal_id;
				interlockerInstanceData[instance].dst_signal_id = forec_intern_input_interlocker_instance_1.dst_signal_id;
				interlockerInstanceData[instance].train_id = forec_intern_input_interlocker_instance_1.train_id;

				// Reset the interlocker so that it can execute its algorithm from the start
				dynlib_interlocker_reset(&interlockers[forec_intern_output_interlocker_instance_1.interlocker_type], &interlockerInstanceData[instance]);
				forec_intern_output_interlocker_instance_1.has_reset = true;
		
				if (interlockerInstanceData[instance].route_id == NULL) {
					interlockerInstanceData[instance].route_id = "";
				}
		
				syslog_server(LOG_NOTICE, "%s: %s.reset() %s %s %s -> \"%s\" %d", threadName, 
						      interlockers[forec_intern_output_interlocker_instance_1.interlocker_type].name,
						      interlockerInstanceData[instance].src_signal_id,
						      interlockerInstanceData[instance].dst_signal_id,
						      interlockerInstanceData[instance].train_id,
						      interlockerInstanceData[instance].route_id,
						      interlockerInstanceData[instance].terminated);
				
				// Update outputs
				forec_intern_output_interlocker_instance_1.route_id = interlockerInstanceData[instance].route_id;
				forec_intern_output_interlocker_instance_1.terminated = interlockerInstanceData[instance].terminated;
				
				// Wait for the reset to be false
				while (forec_intern_input_interlocker_instance_1.reset) {
					pause;
				}
			}
			
			forec_intern_output_interlocker_instance_1.has_reset = false;

			// Execute interlocker until it terminates
			if (!interlockerInstanceData[instance].terminated) {

				while (!interlockerInstanceData[instance].terminated) {
					dynlib_interlocker_tick(&interlockers[forec_intern_output_interlocker_instance_1.interlocker_type], &interlockerInstanceData[instance]);

					if (interlockerInstanceData[instance].route_id == NULL) {
						interlockerInstanceData[instance].route_id = "";
					}

					syslog_server(LOG_NOTICE, "%s: %s.tick() %s %s %s -> \"%s\" %d", threadName, 
								  interlockers[forec_intern_output_interlocker_instance_1.interlocker_type].name,
								  interlockerInstanceData[instance].src_signal_id,
								  interlockerInstanceData[instance].dst_signal_id,
								  interlockerInstanceData[instance].train_id,
								  interlockerInstanceData[instance].route_id,
								  interlockerInstanceData[instance].terminated);
					
					// Update outputs
					forec_intern_output_interlocker_instance_1.route_id = interlockerInstanceData[instance].route_id;
					forec_intern_output_interlocker_instance_1.terminated = interlockerInstanceData[instance].terminated;
					
					pause;
				}
			}
			
			pause;
		}

		forec_intern_output_interlocker_instance_1.interlocker_type = -1;
		forec_intern_output_interlocker_instance_1.in_use = false;
		forec_intern_output_interlocker_instance_1.route_id = "";
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}
thread interlockerInstance2(void) {
	int NULL; (void)NULL;
	#define NULL__interlockerInstance2_0_0 NULL

	unsigned int instance = 2;
	
	const char *threadName;
	threadName = "interlockerInstance0";
			
	while (true) {
		// Wait for a user to set an interlocker
		while (!forec_intern_input_interlocker_instance_2.grab) {
			pause;
		}
		
		forec_intern_output_interlocker_instance_2.interlocker_type = forec_intern_input_interlocker_instance_2.interlocker_type;
		forec_intern_output_interlocker_instance_2.in_use = true;
		interlockerInstanceData[instance].terminated = true;

		// Execute the chosen interlocker
		while (!forec_intern_input_interlocker_instance_2.release) {
			// Reset the interlocker
			if (forec_intern_input_interlocker_instance_2.reset) {
				// Copy inputs
				interlockerInstanceData[instance].src_signal_id = forec_intern_input_interlocker_instance_2.src_signal_id;
				interlockerInstanceData[instance].dst_signal_id = forec_intern_input_interlocker_instance_2.dst_signal_id;
				interlockerInstanceData[instance].train_id = forec_intern_input_interlocker_instance_2.train_id;

				// Reset the interlocker so that it can execute its alglorithm from the start
				dynlib_interlocker_reset(&interlockers[forec_intern_output_interlocker_instance_2.interlocker_type], &interlockerInstanceData[instance]);
				forec_intern_output_interlocker_instance_2.has_reset = true;
		
				if (interlockerInstanceData[instance].route_id == NULL) {
					interlockerInstanceData[instance].route_id = "";
				}
		
				syslog_server(LOG_NOTICE, "%s: %s.reset() %s %s %s -> \"%s\" %d", threadName, 
						      interlockers[forec_intern_output_interlocker_instance_2.interlocker_type].name,
						      interlockerInstanceData[instance].src_signal_id,
						      interlockerInstanceData[instance].dst_signal_id,
						      interlockerInstanceData[instance].train_id,
						      interlockerInstanceData[instance].route_id,
						      interlockerInstanceData[instance].terminated);
				
				// Update outputs
				forec_intern_output_interlocker_instance_2.route_id = interlockerInstanceData[instance].route_id;
				forec_intern_output_interlocker_instance_2.terminated = interlockerInstanceData[instance].terminated;
				
				// Wait for the reset to be false
				while (forec_intern_input_interlocker_instance_2.reset) {
					pause;
				}
			}
			
			forec_intern_output_interlocker_instance_2.has_reset = false;

			// Execute interlocker until it terminates
			if (!interlockerInstanceData[instance].terminated) {

				while (!interlockerInstanceData[instance].terminated) {
					dynlib_interlocker_tick(&interlockers[forec_intern_output_interlocker_instance_2.interlocker_type], &interlockerInstanceData[instance]);

					if (interlockerInstanceData[instance].route_id == NULL) {
						interlockerInstanceData[instance].route_id = "";
					}

					syslog_server(LOG_NOTICE, "%s: %s.tick() %s %s %s -> \"%s\" %d", threadName, 
								  interlockers[forec_intern_output_interlocker_instance_2.interlocker_type].name,
								  interlockerInstanceData[instance].src_signal_id,
								  interlockerInstanceData[instance].dst_signal_id,
								  interlockerInstanceData[instance].train_id,
								  interlockerInstanceData[instance].route_id,
								  interlockerInstanceData[instance].terminated);
					
					// Update outputs
					forec_intern_output_interlocker_instance_2.route_id = interlockerInstanceData[instance].route_id;
					forec_intern_output_interlocker_instance_2.terminated = interlockerInstanceData[instance].terminated;
					
					pause;
				}
			}
			
			pause;
		}

		forec_intern_output_interlocker_instance_2.interlocker_type = -1;
		forec_intern_output_interlocker_instance_2.in_use = false;
		forec_intern_output_interlocker_instance_2.route_id = "";
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}
thread interlockerInstance3(void) {
	int NULL; (void)NULL;
	#define NULL__interlockerInstance3_0_0 NULL

	unsigned int instance = 0;
	
	const char *threadName;
	threadName = "interlockerInstance0";
			
	while (true) {
		// Wait for a user to set an interlocker
		while (!forec_intern_input_interlocker_instance_3.grab) {
			pause;
		}
		
		forec_intern_output_interlocker_instance_3.interlocker_type = forec_intern_input_interlocker_instance_3.interlocker_type;
		forec_intern_output_interlocker_instance_3.in_use = true;
		interlockerInstanceData[instance].terminated = true;

		// Execute the chosen interlocker
		while (!forec_intern_input_interlocker_instance_3.release) {
			// Reset the interlocker
			if (forec_intern_input_interlocker_instance_3.reset) {
				// Copy inputs
				interlockerInstanceData[instance].src_signal_id = forec_intern_input_interlocker_instance_3.src_signal_id;
				interlockerInstanceData[instance].dst_signal_id = forec_intern_input_interlocker_instance_3.dst_signal_id;
				interlockerInstanceData[instance].train_id = forec_intern_input_interlocker_instance_3.train_id;

				// Reset the interlocker so that it can execute its alglorithm from the start
				dynlib_interlocker_reset(&interlockers[forec_intern_output_interlocker_instance_3.interlocker_type], &interlockerInstanceData[instance]);
				forec_intern_output_interlocker_instance_3.has_reset = true;
		
				if (interlockerInstanceData[instance].route_id == NULL) {
					interlockerInstanceData[instance].route_id = "";
				}
		
				syslog_server(LOG_NOTICE, "%s: %s.reset() %s %s %s -> \"%s\" %d", threadName, 
						      interlockers[forec_intern_output_interlocker_instance_3.interlocker_type].name,
						      interlockerInstanceData[instance].src_signal_id,
						      interlockerInstanceData[instance].dst_signal_id,
						      interlockerInstanceData[instance].train_id,
						      interlockerInstanceData[instance].route_id,
						      interlockerInstanceData[instance].terminated);
				
				// Update outputs
				forec_intern_output_interlocker_instance_3.route_id = interlockerInstanceData[instance].route_id;
				forec_intern_output_interlocker_instance_3.terminated = interlockerInstanceData[instance].terminated;
				
				// Wait for the reset to be false
				while (forec_intern_input_interlocker_instance_3.reset) {
					pause;
				}
			}
			
			forec_intern_output_interlocker_instance_3.has_reset = false;

			// Execute interlocker until it terminates
			if (!interlockerInstanceData[instance].terminated) {

				while (!interlockerInstanceData[instance].terminated) {
					dynlib_interlocker_tick(&interlockers[forec_intern_output_interlocker_instance_3.interlocker_type], &interlockerInstanceData[instance]);

					if (interlockerInstanceData[instance].route_id == NULL) {
						interlockerInstanceData[instance].route_id = "";
					}

					syslog_server(LOG_NOTICE, "%s: %s.tick() %s %s %s -> \"%s\" %d", threadName, 
								  interlockers[forec_intern_output_interlocker_instance_3.interlocker_type].name,
								  interlockerInstanceData[instance].src_signal_id,
								  interlockerInstanceData[instance].dst_signal_id,
								  interlockerInstanceData[instance].train_id,
								  interlockerInstanceData[instance].route_id,
								  interlockerInstanceData[instance].terminated);
					
					// Update outputs
					forec_intern_output_interlocker_instance_3.route_id = interlockerInstanceData[instance].route_id;
					forec_intern_output_interlocker_instance_3.terminated = interlockerInstanceData[instance].terminated;
					
					pause;
				}
			}
			
			pause;
		}

		forec_intern_output_interlocker_instance_3.interlocker_type = -1;
		forec_intern_output_interlocker_instance_3.in_use = false;
		forec_intern_output_interlocker_instance_3.route_id = "";
		syslog_server(LOG_NOTICE, "%s: Released container", threadName);

		pause;
	}
}


void copyFilename(char destination[], const char source[], const int name_len, const int path_len) {
	char source_copy[path_len];
	strncpy(source_copy, source, path_len);
	const char *filename = basename(source_copy);
	strncpy(destination, filename, name_len);
}

void copyEngineInputs(t_forec_intern_input_train_engine *internal, 
                      struct t_train_engine_io *external) {
	internal->load = external->input_load;
	internal->unload = external->input_unload;
	strncpy(internal->filepath, external->input_filepath, path_max + name_max);
}

void copyEngineOutputs(struct t_train_engine_io *external, 
                       t_forec_intern_output_train_engine *internal) {
	external->output_in_use = internal->in_use;
	strncpy(external->output_name, internal->name, name_max);
}

void copyEngineInstanceInputs(t_forec_intern_input_train_engine_instance *internal, 
                              struct t_train_engine_instance_io *external) {
	internal->grab = external->input_grab;
	internal->release = external->input_release;
	internal->train_engine_type = external->input_train_engine_type;
	internal->requested_speed = external->input_requested_speed;
	internal->requested_forwards = external->input_requested_forwards;
}

void copyEngineInstanceOutputs(struct t_train_engine_instance_io *external, 
                               t_forec_intern_output_train_engine_instance *internal) {
	external->output_in_use = internal->in_use;
	external->output_train_engine_type = internal->train_engine_type;
	external->output_nominal_speed = internal->nominal_speed;
	external->output_nominal_forwards = internal->nominal_forwards;
}

void unloadEngines(void) {
	for (int i = 0; i < TRAIN_ENGINE_COUNT_MAX; i++) {
		dynlib_close(&trainEngines[i]);
		dyn_containers_interface->train_engines_io[i].output_in_use = false;
	}
	
	for (int i = 0; i < TRAIN_ENGINE_INSTANCE_COUNT_MAX; i++) {
		dyn_containers_interface->train_engine_instances_io[i].output_in_use = false;
	}
}

void copyInterlockerInputs(t_forec_intern_input_interlocker *internal, 
                           struct t_interlocker_io *external) {
	internal->load = external->input_load;
	internal->unload = external->input_unload;
	strncpy(internal->filepath, external->input_filepath, path_max + name_max);
}

void copyInterlockerOutputs(struct t_interlocker_io *external, 
                            t_forec_intern_output_interlocker *internal) {
	external->output_in_use = internal->in_use;
	strncpy(external->output_name, internal->name, name_max);
}

void copyInterlockerInstanceInputs(t_forec_intern_input_interlocker_instance *internal, 
                                   struct t_interlocker_instance_io *external) {
	internal->grab = external->input_grab;
	internal->release = external->input_release;
	internal->interlocker_type = external->input_interlocker_type;
	internal->reset = external->input_reset;
	
	strncpy(internal->src_signal_id, external->input_src_signal_id, name_max);
	strncpy(internal->dst_signal_id, external->input_dst_signal_id, name_max);
	strncpy(internal->train_id, external->input_train_id, name_max);                               
}

void copyInterlockerInstanceOutputs(struct t_interlocker_instance_io *external, 
                                    t_forec_intern_output_interlocker_instance *internal) {
	external->output_in_use = internal->in_use;
	external->output_has_reset = internal->has_reset;
	external->output_interlocker_type = internal->interlocker_type;

	strncpy(external->output_route_id, internal->route_id, name_max);
	external->output_terminated = internal->terminated;
}

void resetInternalInputs(void) {
	forec_intern_input_train_engine_0.load = false;
	forec_intern_input_train_engine_0.unload = false;
	
	forec_intern_input_train_engine_1.load = false;
	forec_intern_input_train_engine_1.unload = false;
	
	forec_intern_input_train_engine_2.load = false;
	forec_intern_input_train_engine_2.unload = false;

	forec_intern_input_train_engine_3.load = false;
	forec_intern_input_train_engine_3.unload = false;
	
	forec_intern_input_train_engine_instance_0.grab = false;
	forec_intern_input_train_engine_instance_0.release = false;

	forec_intern_input_train_engine_instance_1.grab = false;
	forec_intern_input_train_engine_instance_1.release = false;

	forec_intern_input_train_engine_instance_2.grab = false;
	forec_intern_input_train_engine_instance_2.release = false;
	
	forec_intern_input_train_engine_instance_3.grab = false;
	forec_intern_input_train_engine_instance_3.release = false;

	forec_intern_input_train_engine_instance_4.grab = false;
	forec_intern_input_train_engine_instance_4.release = false;

	forec_intern_input_interlocker_0.load = false;
	forec_intern_input_interlocker_0.unload = false;
	
	forec_intern_input_interlocker_1.load = false;
	forec_intern_input_interlocker_1.unload = false;
	
	forec_intern_input_interlocker_2.load = false;
	forec_intern_input_interlocker_2.unload = false;

	forec_intern_input_interlocker_3.load = false;
	forec_intern_input_interlocker_3.unload = false;

	forec_intern_input_interlocker_instance_0.grab = false;
	forec_intern_input_interlocker_instance_0.release = false;
	forec_intern_input_interlocker_instance_0.reset = false;

	forec_intern_input_interlocker_instance_1.grab = false;
	forec_intern_input_interlocker_instance_1.release = false;
	forec_intern_input_interlocker_instance_1.reset = false;
	
	forec_intern_input_interlocker_instance_2.grab = false;
	forec_intern_input_interlocker_instance_2.release = false;
	forec_intern_input_interlocker_instance_2.reset = false;
	
	forec_intern_input_interlocker_instance_3.grab = false;
	forec_intern_input_interlocker_instance_3.release = false;
	forec_intern_input_interlocker_instance_3.reset = false;
}

void resetInternalOutputs(void) {
	forec_intern_output_train_engine_0.in_use = false;
	forec_intern_output_train_engine_1.in_use = false;
	forec_intern_output_train_engine_2.in_use = false;
	forec_intern_output_train_engine_3.in_use = false;

	forec_intern_output_train_engine_instance_0.in_use = false;
	forec_intern_output_train_engine_instance_1.in_use = false;
	forec_intern_output_train_engine_instance_2.in_use = false;
	forec_intern_output_train_engine_instance_3.in_use = false;
	forec_intern_output_train_engine_instance_4.in_use = false;

	forec_intern_output_interlocker_0.in_use = false;
	forec_intern_output_interlocker_1.in_use = false;
	forec_intern_output_interlocker_2.in_use = false;
	forec_intern_output_interlocker_3.in_use = false;

	forec_intern_output_interlocker_instance_0.in_use = false;
	forec_intern_output_interlocker_instance_0.has_reset = false;

	forec_intern_output_interlocker_instance_1.in_use = false;
	forec_intern_output_interlocker_instance_1.has_reset = false;

	forec_intern_output_interlocker_instance_2.in_use = false;
	forec_intern_output_interlocker_instance_2.has_reset = false;

	forec_intern_output_interlocker_instance_3.in_use = false;
	forec_intern_output_interlocker_instance_3.has_reset = false;
}

void unloadInterlockers(void) {
	for (int i = 0; i < INTERLOCKER_COUNT_MAX; i++) {
		dynlib_close(&interlockers[i]);
		dyn_containers_interface->interlockers_io[i].output_in_use = false;
	}

	for (int i = 0; i < INTERLOCKER_INSTANCE_COUNT_MAX; i++) {
		dyn_containers_interface->interlocker_instances_io[i].output_in_use = false;
	}
}

void printout(const char *threadName, const dynlib_status status, const dynlib_data *library) {
	switch (status) {
		case (DYNLIB_COMPILE_SUCCESS):
			syslog_server(LOG_NOTICE, "%s: Compiled shared library '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_LOAD_SUCCESS):
			syslog_server(LOG_NOTICE, "%s: Loaded shared library '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_COMPILE_SCCHARTS_C_ERR):
			syslog_server(LOG_ERR, "%s: Could not compile SCCharts model into C file '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_COMPILE_SHARED_BAHNDSL_ERR):
			syslog_server(LOG_ERR, "%s: Could not compile BahnDSL file into shared library '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_COMPILE_SHARED_SCCHARTS_ERR):
			syslog_server(LOG_ERR, "%s: Could not compile C file into shared library '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_LOAD_ERR):
			syslog_server(LOG_ERR, "%s: Could not load the dynamic library '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_LOAD_RESET_ERR):
			syslog_server(LOG_ERR, "%s: Could not find the address of reset(...) in '%s'", threadName, library->filepath);
			break;
		case (DYNLIB_LOAD_TICK_ERR):
			syslog_server(LOG_ERR, "%s: Could not find the address of tick(...) in '%s'", threadName, library->filepath);
			break;
		default:
			syslog_server(LOG_ERR, "%s: Unknown error %d in '%s'", threadName, status, library->filepath);
			break;
	}
}

TickData_train_engine *keepOneCombineEngine(TickData_train_engine *left[], TickData_train_engine *right[]) {
	return *left;
}

TickData_interlocker *keepOneCombineInterlocker(TickData_interlocker *left[], TickData_interlocker *right[]) {
	return *left;
}
